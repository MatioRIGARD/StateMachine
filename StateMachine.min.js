
class StateMachine {
	
	constructor() {
		this.id = IdGen.getNewId();
		this.name = null;
		this.states = [];
		this.initialState = null;
		this.previousState = null;
		this.currentState = null;
		this.running = false;
	};

	setId(id) {
		this.id = id;
	};

	getId() {
		return this.id;
	};

	setName(name) {
		this.name = name;
	};

	getName() {
		return this.name;
	};

	// set
	setInitialState(state) {
		this.initialState = state;
	};

	addState(state) {
		let localStates = [];

		// add state
		this.states.push(state); /// secure filter
	};

	setTransitionConnections() {
		// pour chaque état
		for(const state in this.states) {
			const stateTransitions = this.states[state].getTransitions();

			// pour chaque transition de chaque état
			for(let transition in stateTransitions) {
				// connect des signaux
				stateTransitions[transition].getSignal().connect(this.onTransitionEmited, this);
			}
		}
	};

	// touts les signaux "transitionSignal" de C_State sont connectées ici
	onTransitionEmited(sender, data) {
		let family = [this.currentState];
		family = family.concat(this.currentState.getFamily());
		
		// pour chaque parents de l'état courant, on récupère les transitions
		for(const parent in family) {
			const transitions = family[parent].getTransitions();
		
			// pour chaque transition
			for(const transition in transitions) {

				// si l'emetteur est égal à l'emetteur du signal enregistré
				if(sender == transitions[transition].getSender()) {
					let nextState = transitions[transition].getNextState();
					if(nextState instanceof State) this.changeState(nextState);
					else if (nextState instanceof HistoryState) this.changeState(nextState.getMemorisedState());
					break;
				}
			}
		}
	};

	// get
	getStates() {
		return this.states;
	};

	// actions
	start() {
		this.changeState(this.initialState);
		this.setTransitionConnections();
		this.running = true;
	};

	stop() {
		this.changeState(this.initialState);
		this.running = false;
	};

	changeState(nextState) {
		let exitStates = null;
		let enterStates = null;

		if(this.currentState == null) {  // onStart
			let children = [nextState];
			children = children.concat(nextState.getChildren());

			for(const element in children) {
				children[element].entered();
				this.currentState = children[element];
			}
		}

		else {  // this.currentState -> nextState
			exitStates = [this.currentState];
			exitStates = exitStates.concat(this.currentState.getFamilyUntilCommonParent(nextState));

			//enterStates = [nextState];
			enterStates = nextState.getChildren().reverse();
			enterStates = enterStates.concat([nextState]);
			enterStates = enterStates.concat(nextState.getFamilyUntilCommonParent(this.currentState));
			enterStates = enterStates.reverse();

			//console.log(enterStates);

			///Action!
			//exit
			for(const state in exitStates) {
				exitStates[state].exited();
				this.currentState = exitStates[state];
				//console.log("Exit states:");
				//console.log(exitStates[state].getId());
			}

			//enter
			for(const state in enterStates) {
				enterStates[state].entered();
				this.currentState = enterStates[state];
				//console.log("Enter state:");
				//console.log(enterStates[state].getId());
			}
		}
	};
}



class State {
	constructor(parent = null) {

		this.id = IdGen.getNewId();
		this.transitions = [];
		this.stateMachine = [];
		
		// signals
		this.sEntered = Signal.create("sEntered");
		this.sExited = Signal.create("sExited");
		this.onEnteredSignalAttributes = [];
		this.onExitedSignalAttributes = [];

		// hierarchy
		this.parent = parent;
		this.initialState = null;

		// history
		this.historyState = null;

		// name
		this.name = null;
	};

	// set
	addTransition(sender, signal, nextState, id=null) {
		this.transitions.push(new Transition(sender, signal, nextState, id));
	};

	setName(name) {
		this.name = name;
	};

	setId(id) {
		this.id = id;
	};

	setParent(parent) {
		this.parent = parent;
	};

	setOnEnteredSignalAttributes(attributes) {
		this.onEnteredSignalAttributes.push(attributes);
	};

	setOnExitedSignalAttributes(attributes) {
		this.onExitedSignalAttributes.push(attributes);
	};

	// getters
	getId() {
		return this.id;
	};

	getName() {
		return this.name;
	};

	getTransitions() {
		return this.transitions;
	};

	getTransitionSignal() {
		return this.transitionSignal;
	};

	getOnEnteredSignalAttributes() {
		return this.onEnteredSignalAttributes;
	};

	getOnExitedSignalAttributes() {
		return this.onExitedSignalAttributes;
	};

	//signals
	entered() {
		console.log("entered "+this.name);
		this.updateHistory();

		for(let attribute in this.onEnteredSignalAttributes) {
			this.sEntered.emit(this, this.onEnteredSignalAttributes[attribute]);
		}
	};

	exited() {
		console.log("exited "+this.name);
		//console.log("exited "+this.id.id.toString());
		for(let attribute in this.onExitedSignalAttributes) {
			this.sExited.emit(this, this.onExitedSignalAttributes[attribute]);
		}
	};

	// hierarchical
	getInitialState() {
		return this.initialState;
	};

	setInitialState(state) {
		this.initialState = state;
	};

	getParent() {
		return this.parent;
	};

	getFamily() {  // ne récupère pas l'étate this
		let family = [];
		let currentParent = this.getParent();

		while(currentParent != null) {
			family.push(currentParent);
			currentParent = currentParent.getParent();
		}

		return family;
	};

	getFamilyUntilCommonParent(state) {
		let thisFamily = this.getFamily();
		let stateFamily = state.getFamily();

		const filteredArray = thisFamily.filter(value => stateFamily.includes(value));

		let firstCommonParent = null;
		if(filteredArray.length > 0) {
			firstCommonParent = filteredArray[0];
		}

		let thisUncommonFamily = [];

		for(const parent in thisFamily) {
			if(thisFamily[parent] == firstCommonParent) {
				break;
			}
			thisUncommonFamily.push(thisFamily[parent]);
		}

		return thisUncommonFamily;
	};

	getChildren() {
		let familyToInitialStates = [];

		let currentInitialState = this.getInitialState();
		while(currentInitialState != null)
		{
			familyToInitialStates.push(currentInitialState);
			currentInitialState = currentInitialState.getInitialState();
		}	

		return familyToInitialStates;
	};
	//history
	setHistory(historyState) {
		this.historyState = historyState;
	};

	getHistory() {
		return this.historyState;
	};

	updateHistory() {
		let family = [this];
		family = family.concat(this.getFamily());
		
		for(const parent in family) {
			if(family[parent] != null) {
				if(family[parent].getHistory() != null) family[parent].getHistory().updateCurrentState(this);
			}
		}
	};
}



class HistoryState {

	constructor(state = null) {
		this.id = IdGen.getNewId();
		this.name = null;
		this.state = null;  // history of this state
		this.currentState = null;
		if(state != null) {
			this.setState(state);
		}
	};

	updateCurrentState(state) {
		this.currentState = state;
	};

	setState(state) {
		this.state = state;
		this.currentState = this.state.getInitialState();
		this.state.setHistory(this);
	}

	setId(id) {
		this.id = id;
	};

	getId() {
		return this.id;
	};

	setName(name) {
		this.name = name;
	};

	getName() {
		return this.name;
	};

	getMemorisedState() {
		return this.currentState;
	};

}



class Transition {
	constructor(sender=null, signal=null, nextState=null, id=null) {
		this.sender = sender;
		this.signal = signal;
		this.nextState = nextState;
		if(id == null) this.id = IdGen.getNewId();
		else this.id = id;
	};

	setTransition(sender, signal, nextState, id=null) {
		this.sender = sender;
		this.signal = signal;
		this.nextState = nextState;
		if(id != null) this.id = id;
	};

	setId(id) {
		this.id = id;
	};

	getId() {
		return this.id;
	};

	getSender() {
		return this.sender;
	};

	getSignal() {
		return this.signal;
	};

	getNextState() {
		return this.nextState;
	};
}



class IdGen {
	static lastId = 0;

	static getNewId() {
		this.lastId++;
		return this.lastId;
	};

	static getLastId() {
		return this.lastId;
	};

	static setLastId(id) {
		this.lastId = id;
	};
}
